#!/usr/bin/env python

"""
names
-----
my_projects -- dev root, my ~/1
bluesky -- the root directory of the bluesky project

The user visits a project:

  $ cd my_projects/bluesky

He sees a build directory, which has only generated code. He wants to keep
the projects under my_projects 'pure', which means they contain only source
code that he wrote. That can be done by 'exiling' the directory:

  $ exile build

The result is that the build is now a symlink to the original build
directory, which now resides in ~/my_projects/.exile/bluesky/

  $ ls -ld ~/my_projects/bluesky/build
    ~/my_projects/bluesky/build -> ~/my_projects/.exile/bluesky/build

The dir ~/my_projects/.exile/bluesky/ was created by the script, if it did not
already exist.

Additional directories may be exiled:

  exile other_peoples_code

If the user decides that a directory was exiled by mistake, he can
'pardon' it.

  pardon build

Pardon is the inverse (undo) of exile. The result is that the build
directory is again local, and there is no longer an entry
`~/my_projects/.exile/bluesky/build`.
"""

import argparse
from collections import namedtuple
import os
import shutil
import sys

Status = namedtuple("Status","status rc errmsg")

def trim(name):
    if name.startswith('./'): 
        name = name[2:]
    if name.endswith('/'):
        name = name[:-1]
    return name

def exile(args):
    """
    * check args.source is a local directory
    * find ancestor directory .exile
    * resolve args.source's parent dir to a simple name
    * ensure that the dir .exile/$dir exists
    * move args.source to .exile/$dir/
    * symlink .exile/$dir/args.source to args.source
    """
    source = trim(args.source)

    def check_source(path):
        if os.path.sep in path:
            return Status(False, 19, 'source must be a local directory')
        if not os.path.exists(path):
            return Status(False, 18, 'source not found')
        if os.path.islink(path):
            return Status(False, 17, 'source may not be a symbolic link')
        if not os.path.isdir(path):
            return Status(False, 16, 'source must be a local directory')
        return Status(True,0,'')

    check = check_source(source)
    if not check.status:
        print >>sys.stderr,check.errmsg
        return check.rc

    def find_exile():
        path = os.getcwd()
        while path != '/': # search towards fs root
            location = os.path.join(path,'.exile')
            if os.path.exists(location):
                return location # found
            path = os.path.split(path)[0]
        return '' # fail

    exile_path = find_exile()
    if not exile_path:
        print >>sys.stderr,'no .exile/ directory found.'
        return 49

    parent_name = os.path.basename(os.getcwd())
    new_home = os.path.join(exile_path,parent_name)
    if not os.path.exists(new_home):
        os.mkdir(new_home)
    target = os.path.join(new_home,source)

    shutil.move(source,target)
    os.symlink(target,source)

    return 0

if __name__ == '__main__':
    p = argparse.ArgumentParser(description='Exile the named directory')
    p.add_argument('source',help='directory to exile')
    p.set_defaults(func=exile)
    args = p.parse_args()
    sys.exit(args.func(args))

    
